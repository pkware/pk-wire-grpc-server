// Code generated by Wire protocol buffer compiler, do not edit.
package test

import com.google.protobuf.DescriptorProtos
import com.google.protobuf.Descriptors
import com.squareup.wire.kotlin.grpcserver.WireBindableService
import com.squareup.wire.kotlin.grpcserver.WireMethodMarshaller
import io.grpc.CallOptions
import io.grpc.Channel
import io.grpc.MethodDescriptor
import io.grpc.ServerServiceDefinition
import io.grpc.ServiceDescriptor
import io.grpc.ServiceDescriptor.newBuilder
import io.grpc.stub.AbstractStub
import io.grpc.stub.BlockingClientCall
import io.grpc.stub.ClientCalls.blockingServerStreamingCall
import io.grpc.stub.ClientCalls.blockingV2ServerStreamingCall
import io.grpc.stub.StreamObserver
import java.io.InputStream
import java.lang.Class
import java.lang.UnsupportedOperationException
import kotlin.Array
import kotlin.String
import kotlin.Unit
import kotlin.collections.Iterator
import kotlin.collections.Map
import kotlin.collections.Set
import kotlin.jvm.Volatile
import io.grpc.stub.ClientCalls.asyncServerStreamingCall as clientCallsAsyncServerStreamingCall
import io.grpc.stub.ServerCalls.asyncServerStreamingCall as serverCallsAsyncServerStreamingCall

public object TestServiceWireGrpc {
  public const val SERVICE_NAME: String = "test.TestService"

  @Volatile
  private var serviceDescriptor: ServiceDescriptor? = null

  private val descriptorMap: Map<String, DescriptorProtos.FileDescriptorProto> =
      createDescriptorMap0()

  @Volatile
  private var getTestRPCMethod: MethodDescriptor<Test, Test>? = null

  private fun descriptorFor(`data`: Array<String>): DescriptorProtos.FileDescriptorProto {
    val str = data.fold(java.lang.StringBuilder()) { b, s -> b.append(s) }.toString()
    val bytes = java.util.Base64.getDecoder().decode(str)
    return DescriptorProtos.FileDescriptorProto.parseFrom(bytes)
  }

  private fun fileDescriptor(path: String, visited: Set<String>): Descriptors.FileDescriptor {
    val proto = descriptorMap[path]!!
    val deps = proto.dependencyList.filter { !visited.contains(it) }.map { fileDescriptor(it, visited + path) }
    return Descriptors.FileDescriptor.buildFrom(proto, deps.toTypedArray())
  }

  private fun createDescriptorMap0(): Map<String, DescriptorProtos.FileDescriptorProto> {
    val subMap = mapOf(
      "service.proto" to descriptorFor(arrayOf(
        "Cg1zZXJ2aWNlLnByb3RvEgR0ZXN0IgYKBFRlc3QyMgoLVGVzdFNlcnZpY2USIwoHVGVzdFJQQxIKLnRl",
        "c3QuVGVzdBoKLnRlc3QuVGVzdDAB",
      )),
    )
    return subMap
  }

  public fun getServiceDescriptor(): ServiceDescriptor? {
    var result = serviceDescriptor
    if (result == null) {
      synchronized(TestServiceWireGrpc::class) {
        result = serviceDescriptor
        if (result == null) {
          result = newBuilder(SERVICE_NAME)
          .addMethod(getTestRPCMethod())
          .setSchemaDescriptor(io.grpc.protobuf.ProtoFileDescriptorSupplier {
                fileDescriptor("service.proto", emptySet())
              })
          .build()
          serviceDescriptor = result
        }
      }
    }
    return result
  }

  public fun getTestRPCMethod(): MethodDescriptor<Test, Test> {
    var result: MethodDescriptor<Test, Test>? = getTestRPCMethod
    if (result == null) {
      synchronized(TestServiceWireGrpc::class) {
        result = getTestRPCMethod
        if (result == null) {
          getTestRPCMethod = MethodDescriptor.newBuilder<Test, Test>()
            .setType(MethodDescriptor.MethodType.SERVER_STREAMING)
            .setFullMethodName(
              MethodDescriptor.generateFullMethodName(
                "test.TestService", "TestRPC"
              )
            )
            .setSampledToLocalTracing(true)
            .setRequestMarshaller(TestServiceImplBase.TestMarshaller())
            .setResponseMarshaller(TestServiceImplBase.TestMarshaller())
            .build()
        }
      }
    }
    return getTestRPCMethod!!
  }

  public fun newStub(channel: Channel): TestServiceStub = TestServiceStub(channel)

  public fun newBlockingStub(channel: Channel): TestServiceBlockingStub = TestServiceBlockingStub(channel)

  public abstract class TestServiceImplBase : WireBindableService {
    public open fun TestRPC(request: Test, response: StreamObserver<Test>): Unit = throw UnsupportedOperationException()

    override fun bindService(): ServerServiceDefinition = ServerServiceDefinition.builder(getServiceDescriptor()).addMethod(
              getTestRPCMethod(),
              serverCallsAsyncServerStreamingCall(this@TestServiceImplBase::TestRPC)
            ).build()

    public class TestMarshaller : WireMethodMarshaller<Test> {
      override fun stream(`value`: Test): InputStream = Test.ADAPTER.encode(value).inputStream()

      override fun marshalledClass(): Class<Test> = Test::class.java

      override fun parse(stream: InputStream): Test = Test.ADAPTER.decode(stream)
    }
  }

  public class TestServiceStub : AbstractStub<TestServiceStub> {
    internal constructor(channel: Channel) : super(channel)

    internal constructor(channel: Channel, callOptions: CallOptions) : super(channel, callOptions)

    override fun build(channel: Channel, callOptions: CallOptions): TestServiceStub = TestServiceStub(channel, callOptions)

    public fun TestRPC(request: Test, response: StreamObserver<Test>) {
      clientCallsAsyncServerStreamingCall(channel.newCall(getTestRPCMethod(), callOptions), request, response)
    }
  }

  public class TestServiceBlockingStub : AbstractStub<TestServiceBlockingStub> {
    internal constructor(channel: Channel) : super(channel)

    internal constructor(channel: Channel, callOptions: CallOptions) : super(channel, callOptions)

    override fun build(channel: Channel, callOptions: CallOptions): TestServiceBlockingStub = TestServiceBlockingStub(channel, callOptions)

    public fun TestRPC(request: Test): Iterator<Test> = blockingServerStreamingCall(channel, getTestRPCMethod(), callOptions, request)

    public fun TestRPCCall(request: Test): BlockingClientCall<Test, Test> = blockingV2ServerStreamingCall(channel, getTestRPCMethod(), callOptions, request)
  }
}
